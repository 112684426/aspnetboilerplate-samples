<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="tr" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Untitled 1</title>
</head>

<body>

<h2>Contents</h2>
<ul>
	<li>Introduction</li>
</ul>
<h2>Introduction</h2>
<p>In this article, I'll show to create a simple <strong>layered</strong> web 
application using the following tools:</p>
<ul>
	<li><a href="http://www.aspnetboilerplate.com/" target="_blank">ASP.NET 
	Boilerplate</a> (ABP) as startup template and application framework.</li>
	<li><a href="https://docs.asp.net/" target="_blank">ASP.NET Core</a> MVC 1.0 
	as web framework.</li>
	<li><a href="https://docs.efproject.net/" target="_blank">Entity Framework 
	Core</a> 1.0 as ORM framework.</li>
	<li><a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> 
	as HTML&amp;CSS framework.</li>
	<li><a href="http://jquery.com/" target="_blank">jQuery</a> as client side 
	AJAX/DOM library.</li>
</ul>
<p>We will also use
<a href="https://logging.apache.org/log4net/" target="_blank">Log4Net</a> and
<a href="http://automapper.org/" target="_blank">AutoMapper</a> which are 
included in ABP
<a href="http://www.aspnetboilerplate.com/Templates" target="_blank">startup 
template</a> by default. We will also use the following techniques:</p>
<ul>
	<li>
	<a href="http://aspnetboilerplate.com/Pages/Documents/NLayer-Architecture" target="_blank">
	Layered Architecture</a></li>
	<li>
	<a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank">
	Domain Driven Design</a> (DDD)</li>
	<li>
	<a href="http://www.aspnetboilerplate.com/Pages/Documents/Dependency-Injection" target="_blank">
	Dependency injection</a> (DI)</li>
	<li>
	<a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank">
	Integration Testing</a></li>
</ul>
<p>The project will be developed here is a simple task management application 
where tasks can be assigned to people. Instead of developing the application 
layer by layer, I will go to vertical and change the layers as the application 
grows. While the application grows, I will introduce some features of ABP and 
other frameworks as needed.</p>
<h2>Create the Application</h2>
<p>I used ABP's startup template to create a new web application named "<strong>Acme.SimpleTaskApp</strong>" 
(company name, Acme, is optional):</p>
<p>
<img alt="ABP startup template creation" height="427" src="Template-Creation.png" width="533" /></p>
<p>It creates an layered solution as shown below:&nbsp;</p>
<p>
<img alt="Startup template projects" height="184" src="Template-Projects.png" width="303" /></p>
<p>It includes 6 projects starting with the name that I entered as the project 
name:</p>
<ul>
	<li><strong>.Core</strong> project is for domain/business layer (entities, 
	domain services...)</li>
	<li><strong>.Application</strong> project is for application layer (DTOs, 
	application services...)</li>
	<li><strong>.EntityFramework</strong> project is for EF Core integration 
	(abstracts EF Core from other layers).</li>
	<li><strong>.Web</strong> project is for ASP.NET MVC layer.</li>
	<li><strong>.Tests</strong> project is for unit and integration tests (up to 
	application layer, excluding web layer)</li>
	<li><strong>.Web.Tests</strong> project is for ASP.NET Core integrated tests 
	(complete integration test for server side).</li>
</ul>
<h2>Developing the Application</h2>
<h3>Creating a Task Entity</h3>
<p>I want to start with a simple&nbsp;<strong>Task</strong> entity. Since an 
entity is part of the domain layer, I added it into the <strong>.Core </strong>
project:</p>
<pre lang="cs">[Table(&quot;<strong>AppTasks</strong>&quot;)]
public class <strong>Task : Entity, IHasCreationTime</strong>
{
    public const int MaxTitleLength = 256;
    public const int MaxDescriptionLength = 64 * 1024; //64KB

    [Required]
    [MaxLength(MaxTitleLength)]
    public string Title { get; set; }

    [MaxLength(MaxDescriptionLength)]
    public string Description { get; set; }

    public DateTime CreationTime { get; set; }

    public TaskState State { get; set; }

    public Task()
    {
        CreationTime = <strong>Clock.Now</strong>;
        State = TaskState.Open;
    }

    public Task(string title, string description = null)
        :this()
    {
        Title = title;
        Description = description;
    }
}

public enum <strong>TaskState : byte
</strong>{
    Open = 0,
    Completed = 1
}</pre>
<ul>
	<li>I derived from ABP's base <strong>
	<a href="http://www.aspnetboilerplate.com/Pages/Documents/Entities" target="_blank">
	Entity</a></strong>&nbsp;class, which includes <strong>Id</strong> property as
	<strong>int</strong> by default. We can use the generic version, <strong>
	Entity&lt;TPrimaryKey&gt;,</strong> to choice a different PK type.</li>
	<li><strong>IHasCreationTime</strong> is a simple interface just defines
	<strong>CreationTime</strong> property.</li>
	<li>Task defines a required Title and an optional Description.</li>
	<li><strong>TaskState</strong> is a simple enum to define states of a Task 
	entity.</li>
	<li><strong>Clock.Now</strong> returns DateTime.Now by default. But it 
	provides an abstraction, so we can easily switch to DateTime.UtcNow in the 
	feature if it's needed. So, always use Clock.Now instead of DateTime.Now.</li>
	<li>I wanted to store Task entities into <strong>AppTasks</strong> table in 
	the database.</li>
</ul>
<h3>Adding Task to DbContext</h3>
<p><strong>.EntityFrameworkCore</strong> project includes a pre-defined <strong>DbContext</strong>. I should add 
a <strong>DbSet</strong> for the Task entity into the DbContext:</p>
<pre lang="cs">public class SimpleTaskAppDbContext : AbpDbContext
{
    <strong>public DbSet&lt;Task&gt; Tasks { get; set; }</strong>

    public SimpleTaskAppDbContext(DbContextOptions&lt;SimpleTaskAppDbContext&gt; options) 
        : base(options)
    {

    }
}</pre>
<p>Now, EF Core knows that we have a Task entity.&nbsp;</p>
<h3>Creating the First Database Migration&nbsp;</h3>
<p>We will create an initial migration to create database and the AppTasks 
table. I open the <strong>Windows Command Line</strong> and run the following 
command:</p>
<p>
<img alt="EF Core Initial Migration" height="51" src="EF-Core-Initial-Migration.png" width="660" /></p>
<p>This command creates a <strong>Migrations</strong>&nbsp;folder in the 
.EntityFrameworkCore project which includes a migration class and a snapshot of 
our database model:</p>
<p>
<img alt="EntityFrameworkCore Project Migrations" height="237" src="EntityFrameworkCore-Project-Migrations.png" width="327" />&nbsp;</p>
<p><strong>Automatically generated</strong> "Initial" migration class is&nbsp;shown below:</p>
<pre lang="cs">public partial class Initial : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: &quot;AppTasks&quot;,
            columns: table =&gt; new
            {
                Id = table.Column&lt;int&gt;(nullable: false)
                    .Annotation(&quot;SqlServer:ValueGenerationStrategy&quot;, SqlServerValueGenerationStrategy.IdentityColumn),
                CreationTime = table.Column&lt;DateTime&gt;(nullable: false),
                Description = table.Column&lt;string&gt;(maxLength: 65536, nullable: true),
                State = table.Column&lt;byte&gt;(nullable: false),
                Title = table.Column&lt;string&gt;(maxLength: 256, nullable: false)
            },
            constraints: table =&gt;
            {
                table.PrimaryKey(&quot;PK_AppTasks&quot;, x =&gt; x.Id);
            });
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(
            name: &quot;AppTasks&quot;);
    }
}</pre>
<p>This code is used to create AppTasks table when we execute the migrations to 
the database. </p>
<h3>Creating the Database</h3>
<p>To create the database, I run the following command in the command line:</p>
<p>
<img alt="dotnet ef database update" height="44" src="EF-Core-Database-Update.png" width="558" /></p>
<p>This command created a database named <strong>SimpleTaskAppDb</strong> in the 
local SQL Server and executed the migrations (currently, there is a single, 
Initial, migration):</p>
<p>
<img alt="Created Database" height="140" src="Created-Database.png" width="211" /></p>
<p>Now, I have a Task entity and corresponding table in the database.&nbsp; I entered 
a few sample Tasks to the table:</p>
<p><img alt="AppTasks table" height="81" src="apptasks-table.png" width="579" /></p>
<p>Note that, the database <strong>connection string</strong> is defined in
<strong>appsettings.json</strong> in the <strong>.Web</strong> application.</p>
<h3>Task Application Service</h3>
<p><em>
<a href="http://www.aspnetboilerplate.com/Pages/Documents/Application-Services" target="_blank">Application Services</a> are used to expose domain logic to the presentation layer. 
An Application Service is called from presentation layer with a 
<a href="http://www.aspnetboilerplate.com/Pages/Documents/Data-Transfer-Objects" target="_blank">
Data Transfer Object</a> (DTO) as parameter (if needed),
uses domain objects to perform some specific business logic and returns a DTO back to the presentation layer 
(if needed).</em></p>
<p>I'm creating the first application service, <strong>TaskAppService</strong>,&nbsp;into 
the <strong>.Application</strong> project to perform task related application 
logic. First, I wanted to define an interface for the app service:</p>
<pre lang="cs">public interface ITaskAppService : <strong>IApplicationService</strong>
{
    Task&lt;ListResultOutput&lt;TaskListDto&gt;&gt; GetAll(GetAllTasksInput input);
}</pre>
<p>Defining an interface is not required, but suggested. By convention, all app 
services <strong>should</strong> implement <strong>IApplicationService</strong> interface in ABP. I just created a
<strong>GetAll</strong> method to query tasks. To do that, I also defined the following DTOs:</p>
<pre lang="cs">public class GetAllTasksInput
{
    public TaskState? State { get; set; }
}

<strong>[AutoMapFrom(typeof(Task))]</strong>
public class TaskListDto : EntityDto
{
    public string Title { get; set; }

    public string Description { get; set; }

    public DateTime CreationTime { get; set; }

    public TaskState State { get; set; }
}</pre>
<ul>
	<li><strong>GetAllTasksInput</strong> DTO defines parameters of the <strong>GetAll</strong> app service method. Instead of directly defining the 
	<strong>state</strong> as method parameter, I added it into a DTO object. Thus, I can 
add other parameters into this DTO later without breaking my existing clients.</li>
	<li><strong>TaskListDto</strong> is used to return a Task data. It's derived from
	<strong>EntityDto</strong>, which just defines an <strong>Id </strong>property 
(we could add Id to our Dto and not derive from EntityDto, no problem). We 
	defined [<strong>AutoMapFrom</strong>] attribute to create
	<a href="http://automapper.org/" target="_blank">AutoMapper</a> mapping from 
	Task entity to TaskListDto. This attribute is defined in
	<a href="http://nuget.org/packages/Abp.AutoMapper" target="_blank">
	Abp.AutoMapper</a> nuget package.</li>
	<li>Lastly, <strong>ListResultOutput</strong> is a simple class contains a 
	list of items (we could directly return a List&lt;TaskListDto&gt;, no problem).</li>
</ul>
<p>Now, we can implement the <strong>ITaskAppService</strong> as shown below:</p>
<pre lang="cs">public class TaskAppService : <strong>SimpleTaskAppAppServiceBase</strong>, <strong>ITaskAppService</strong>
{
    private readonly IRepository&lt;Task&gt; _taskRepository;

    public TaskAppService(<strong>IRepository&lt;Task&gt; taskRepository</strong>)
    {
        _taskRepository = taskRepository;
    }

    public async Task&lt;ListResultOutput&lt;TaskListDto&gt;&gt; GetAll(GetAllTasksInput input)
    {
        var tasks = await _taskRepository
            .GetAll()
            <strong>.WhereIf(input.State.HasValue, t =&gt; t.State == input.State.Value)</strong>
            .ToListAsync();

        return new ListResultOutput&lt;TaskListDto&gt;(
            <strong>ObjectMapper.Map&lt;List&lt;TaskListDto&gt;&gt;(tasks)</strong>
      ););
    }
}</pre>
<ul>
	<li><strong>TaskAppService</strong> is derived from <strong>
	SimpleTaskAppAppServiceBase</strong> included in the startup template (which 
	is derived from ABP's ApplicationService class). This is not required, app 
	services can be plain classes. But <strong>ApplicationService</strong> base 
	class has some pre-injected services (like ObjectMapper used here).</li>
	<li>I used
	<a href="http://www.aspnetboilerplate.com/Pages/Documents/Dependency-Injection" target="_blank">
	dependency injection</a> to get a
	<a href="http://www.aspnetboilerplate.com/Pages/Documents/Repositories" target="_blank">
	repository</a>.</li>
	<li><strong>Repositories</strong> are used to abstract database operations 
	for entities. ABP creates a pre-defined repository (like IRepository&lt;Task&gt; 
	here) to perform common tasks. IRepository.<strong>GetAll() </strong>used 
	here returns an <strong>IQueryable</strong> to query entities.</li>
	<li><strong>WhereIf</strong> is an extension method of ABP to simplify 
	conditional usage of IQueryable.Where method.</li>
	<li><strong>ObjectMapper</strong> (which somes from the ApplicationService 
	base class and implemented via AutoMapper by default) is used to map list of 
	Task objects to list of TaskListDtos objects.</li>
</ul>
<h3>Testing the TaskAppService</h3>
<p>Before going further to create user interface, I want to test TaskAppService. 
Startup template contains .Tests project to test our code.</p>
<p>s</p>
<p>TODO: Discussions</p>
<p>* Why not used domain services?&nbsp;</p>

</body>

</html>
