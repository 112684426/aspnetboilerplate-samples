<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="tr" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Using ASP.NET Core, Entity Framework Core and ASP.NET Boilerplate to Create NLayered Web Application</title>
</head>

<body>

<ul class="download">
	<li><a href="SimpleTaskApp.zip">Download sample application</a> (or see latest on <a href="https://github.com/aspnetboilerplate/aspnetboilerplate-samples/tree/master/SimpleTaskSystem-Core" target="_blank">github)</a></li>
</ul>

<h2>Contents</h2>
<ul>
	<li><a href="#ArticleIntro">Introduction</a></li>
	<li>...</li>
	<li><a href="#ArticleMore">More</a></li>
	<li><a href="#ArticleHistory">Article History</a></li>
</ul>

<h2 id="ArticleIntro">Introduction</h2>

<p>This is second part of the "<em>Using ASP.NET Core, Entity Framework Core and 
ASP.NET Boilerplate to Create NLayered Web Application</em>" article series. See 
other parts:</p>
<ul>
	<li>
	<a href="http://www.codeproject.com/Articles/1115763/Using-ASP-NET-Core-Entity-Framework-Core-and-ASP-N">
	Part I - Using ASP.NET Core, Entity Framework Core and ASP.NET Boilerplate 
	to Create NLayered Web Application</a></li>
	<li>Part II (this one) - Using ASP.NET Core, Entity Framework Core and 
	ASP.NET Boilerplate to Create NLayered Web Application</li>
</ul>

<h2 id="ArticleDevelopApp">Developing the Application</h2>

<h3 id="ArticleCreateTaskEntity">Creating the Person Entity</h3>

<p>I'll add <strong>Person</strong> concept to the application to <strong>assign tasks</strong> to people. So, I 
define a simple <strong>Person entity</strong>:</p>
<pre lang="cs"><strong>[Table(&quot;AppPersons&quot;)]</strong>
public class Person : <strong>AuditedEntity&lt;Guid&gt;</strong>
{
    public const int MaxNameLength = 32;

    [Required]
    [MaxLength(MaxNameLength)]
    public string Name { get; set; }

    public Person()
    {
            
    }

    public Person(string name)
    {
        Name = name;
    }
}</pre>
<p>This time, I set Id (primary key)&nbsp; type as <strong>Guid</strong>, for 
demonstration. I also derived from <strong>AuditedEntity</strong> (which has 
CreationTime, CreaterUserId, LastModificationTime and LastModifierUserId 
properties) instead of base Entity class.</p>
<h3>Relating Person to the Task Entity</h3>
<p>I'm also adding <strong>AssignedPerson</strong> property to the <strong>Task</strong> entity 
(only sharing the changed parts here):</p>
<pre lang="cs">[Table(&quot;AppTasks&quot;)]
public class Task : Entity, IHasCreationTime
{
    //...

<strong>    [ForeignKey(nameof(AssignedPersonId))]
    public Person AssignedPerson { get; set; }
    public Guid? AssignedPersonId { get; set; }</strong>

    public Task(string title, string description = null, <strong>Guid? assignedPersonId = null</strong>)
        : this()
    {
        Title = title;
        Description = description;
        <strong>AssignedPersonId = assignedPersonId;</strong>
    }
}</pre>

<p>AssignedPerson is <strong>optional</strong>. So, as task can be assigned to a 
person or 
can be unassigned.</p>
<h3>Adding Person to DbContext</h3>
<p>Finally, I'm adding new Person entity to the DbContext class:</p>
<pre lang="cs">public class SimpleTaskAppDbContext : AbpDbContext
{
    <strong>public DbSet&lt;Person&gt; People { get; set; }</strong>
    
    //...
}</pre>
<h3>Adding a New Migration for Person Entity</h3>
<p>Now, I'm running the following command in the command line:</p>
<p>
<img alt="dotnet ef migrations add" height="38" src="migration-add-person.png" width="670" /></p>
<p>And it creates a new migration class in the project:</p>
<pre lang="cs">public partial class Added_Person : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: &quot;AppPersons&quot;,
            columns: table =&gt; new
            {
                Id = table.Column&lt;Guid&gt;(nullable: false),
                CreationTime = table.Column&lt;DateTime&gt;(nullable: false),
                CreatorUserId = table.Column&lt;long&gt;(nullable: true),
                LastModificationTime = table.Column&lt;DateTime&gt;(nullable: true),
                LastModifierUserId = table.Column&lt;long&gt;(nullable: true),
                Name = table.Column&lt;string&gt;(maxLength: 32, nullable: false)
            },
            constraints: table =&gt;
            {
                table.PrimaryKey(&quot;PK_AppPersons&quot;, x =&gt; x.Id);
            });

        migrationBuilder.AddColumn&lt;Guid&gt;(
            name: &quot;AssignedPersonId&quot;,
            table: &quot;AppTasks&quot;,
            nullable: true);

        migrationBuilder.CreateIndex(
            name: &quot;IX_AppTasks_AssignedPersonId&quot;,
            table: &quot;AppTasks&quot;,
            column: &quot;AssignedPersonId&quot;);

        migrationBuilder.AddForeignKey(
            name: &quot;FK_AppTasks_AppPersons_AssignedPersonId&quot;,
            table: &quot;AppTasks&quot;,
            column: &quot;AssignedPersonId&quot;,
            principalTable: &quot;AppPersons&quot;,
            principalColumn: &quot;Id&quot;,
            onDelete: <strong>ReferentialAction.SetNull</strong>);
    }

    //...
}</pre>
<p>I just changed ReferentialAction.Restrict to ReferentialAction.SetNull. It 
does that: if I delete a person, assigned tasks to that person become 
unassigned. This is not important in this demo. But I wanted to show that you 
can change the migration code if you need. Actually, you always review the 
generated code before applying it to the database. After that, we can <strong>
apply migration</strong> to our database:</p>
<p>
<img alt="dotnet ef database update" height="33" src="migration-person-update.png" width="558" /></p>
<p>When we open the database, we can see the new table and columns and add some 
test data:</p>
<p><img alt="Person table" height="79" src="person-table.png" width="668" /></p>
<p>I added a person and assigned to the first task:</p>
<p>
<img alt="Tasks table" height="118" src="tasks-table-with-person.png" width="649" /></p>
<h3>Return Assigned Person in the Task List</h3>
<p>I'll change the <strong>TaskAppService</strong> to return assigned person information. First, 
I'm adding two properties to <strong>TaskListDto</strong>:</p>
<pre lang="cs">[AutoMapFrom(typeof(Task))]
public class TaskListDto : EntityDto, IHasCreationTime
{
    //...

<strong>    public Guid? AssignedPersonId { get; set; }

    public string AssignedPersonName { get; set; }</strong>
}</pre>
<p>And including the Task.AssignedPerson property to the query (just added the 
Include line):</p>
<pre lang="cs">public class TaskAppService : SimpleTaskAppAppServiceBase, ITaskAppService
{
    //...

    public async Task&lt;ListResultOutput&lt;TaskListDto&gt;&gt; GetAll(GetAllTasksInput input)
    {
        var tasks = await _taskRepository
            .GetAll()
            <strong>.Include(t =&gt; t.AssignedPerson)</strong>
            .WhereIf(input.State.HasValue, t =&gt; t.State == input.State.Value)
            .OrderByDescending(t =&gt; t.CreationTime)
            .ToListAsync();

        return new ListResultOutput&lt;TaskListDto&gt;(
            ObjectMapper.Map&lt;List&lt;TaskListDto&gt;&gt;(tasks)
        );
    }
}</pre>
<p>Thus, GetAll method will return Assigned person information with the tasks. 
Since we used AutoMapper, new properties will also be copied to DTO 
automatically.</p>
<h3>Change Unit Test to Test Assigned Person</h3>
<p>At this point, we can change unit tests to see if assigned people are 
retrieved while getting the task list. First, I changed initial test data in the 
TestDataBuilder class to assign a person to a task:</p>
<pre lang="cs">public class TestDataBuilder
{
    //...

    public void Build()
    {
<strong>        var neo = new Person(&quot;Neo&quot;);
        _context.People.Add(neo);
        _context.SaveChanges();</strong>

        _context.Tasks.AddRange(
            new Task(&quot;Follow the white rabbit&quot;, &quot;Follow the white rabbit in order to know the reality.&quot;, <strong>neo.Id</strong>),
            new Task(&quot;Clean your room&quot;) { State = TaskState.Completed }
            );
    }
}</pre>
<p>Then I'm changing TaskAppService_Tests.Should_Get_All_Tasks() method to check 
if one of the retrieved tasks has a person assigned (see the last line added):</p>
<pre lang="cs">[Fact]
public async System.Threading.Tasks.Task Should_Get_All_Tasks()
{
    //Act
    var output = await _taskAppService.GetAll(new GetAllTasksInput());

    //Assert
    output.Items.Count.ShouldBe(2);
    <strong>output.Items.Count(t =&gt; t.AssignedPersonName != null).ShouldBe(1);
</strong>}</pre>
<p>&nbsp;</p>
<p>...</p>

<h2 id="ArticleHistory">Article History</h2>

<ul>
	<li><strong>2016-08-08</strong>: Initial publication.</li>
</ul>

</body>

</html>
